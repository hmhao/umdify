'use strict';


var esprima = require('esprima');

var MAGIC_DEPS = {
	'exports' : true,
	'module' : true,
	'require' : true
};


var _traverse = function(node, visitor) {
	if (!node) {
		return;
	}

	if (visitor.call(null, node) === false) {
		return false;
	}

	for (var key in node) {
		if (node.hasOwnProperty(key)) {
			var child = node[key];
			if (typeof child === 'object' && child !== null) {
				if (_traverse(child, visitor) === false) {
					return false;
				}
			}
		}
	}
};


var _getDefine = function(ast) {
	var defines = [];

	_traverse(ast, function(node) {
		if (
			node &&
			node.type === 'ExpressionStatement' &&
			node.expression.type === 'CallExpression' &&
			node.expression.callee.type === 'Identifier' &&
			node.expression.callee.name === 'define'
		) {
			defines.push(node);
		}
	});

	if (!defines.length) {
		throw new Error('AMD modules must contain a define() call');
	}

	if (defines.length > 1) {
		throw new Error('AMD modules can have only a single define call. Found '+ defines.length + '.');
	}

	return defines[0];
};


// define(['mod1', 'mod2']...
var _getArrayDependencies = function(ast) {
	var factory = _getDefine(ast);
	var names = [];
	var identifiers = [];
	var args = factory.expression['arguments'];

	for (var i = 0; i < args.length; i++) {
		if (args[i].type === 'ArrayExpression') {
			names = args[i].elements.map(function(obj) {
				return obj.value;
			});
			identifiers = args[i + 1].params.map(function(obj) {
				return obj.name;
			});
		}
	}

	return names.map(function(name, i) {
		return {
			modName: name,
			varIdentifier: identifiers[i]
		};
	});
};


// var mod1 = require('mod1')
var _getCjsDependencies = function(ast) {
	var deps = [];

	_traverse(ast, function(node) {
		if (
			node &&
			node.type === 'CallExpression' &&
			node.callee &&
			node.callee.type === 'Identifier' &&
			node.callee.name === 'require' &&
			node['arguments'] &&
			node['arguments'].length === 1 &&
			node['arguments'][0].type === 'Literal'
		) {
			deps.push(node['arguments'][0].value);
		}
	});

	return deps;
};


// convert amd dependency array to simplified cjs style
var _makeRequireStatements = function(deps) {
	var ret = [];
	var paramNames = [];
	deps.forEach(function(dep){
		if (MAGIC_DEPS[dep.varIdentifier] && !MAGIC_DEPS[dep.modName]) {
			// if user remaped magic dependency we declare a var
			ret.push(dep.modName);
		}
		else if (dep.varIdentifier && !MAGIC_DEPS[dep.varIdentifier]) {
			// only do require for params that have a matching dependency
			// also skip "magic" dependencies
			ret.push('require(\'' + dep.modName + '\')');
		}
		paramNames.push(dep.varIdentifier)
	});
	return {paramNames: paramNames, requires: ret};
};

var defaultOptions = {
	moduleName: 'returnExports'
};

// Convert AMD-style JavaScript string into node.js compatible module
var umdify = function(contents, options) {
	options = Object.assign({}, defaultOptions, options);

	var ast = options.ast = esprima.parse(contents, {
		range: true,
		raw: true
	});

	var def = options.def = _getDefine(ast);
	var factory = options.factory = def.expression['arguments'].filter(function(arg) {
		return arg.type === 'FunctionExpression';
	})[0];

	var bodyAst = options.bodyAst = factory.body;
	var useStrict = options.useStrict = bodyAst.body.filter(function(node) {
		return node.type === 'ExpressionStatement' &&
				node.expression.type === 'Literal' &&
				node.expression.value === 'use strict';
	})[0];

	var cjsDeps = _getCjsDependencies(ast);
	var arrayDeps = _getArrayDependencies(ast);
	// cjs-style require() statements for array deps
	var requireStatements = _makeRequireStatements(arrayDeps.filter(function(dep) {
		return cjsDeps.indexOf(dep.modName) === -1;
	}));
	var depNames = arrayDeps
		.map(function(dep) {
			return dep.modName;
		})
		.concat(cjsDeps)
		.map(function(dep) {
			return '\'' + dep + '\'';
		});

	depNames = depNames.reverse().filter(function(name, i, list) {
		return list.indexOf(name, i+1) === -1;
	}).reverse();

	options.amd = depNames;
	options.cmd = requireStatements.requires;
	options.params = requireStatements.paramNames;

	return render(contents, options);
};

var render = function (contents, options) {

	var output = '';

	// anything before define
	output += contents.substring(0, options.def.range[0]);

	// UMD definition
	output += '// This was autogenerated by umdify-cli\n';
	output += '// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js\n';
	output += '(function (root, factory) {\n';
	output += "  if (typeof define === 'function' && define.amd) {\n";
	if (options.amd.length > 0) {
		output += '    define([\n      ' + options.amd.join(',\n      ') + '\n    ], factory);\n';
	} else {
		output += '    define([], factory);\n';
	}
	output += "  } else if (typeof exports === 'object') {\n";

	if (options.cmd.length > 0 ){
		output += '    module.exports = factory(\n      ' + options.cmd.join(',\n      ') + '\n    );';
	} else {
		output += '    module.exports = factory();';
	}

	output += '\n  } else {\n';

	if (options.params.length > 0) {
		output += '    root.' + options.moduleName + ' = factory(\n      root.' +options.params.join(',\n      root.')+ '\n    );\n';
	} else {
		output += '    root.' + options.moduleName + ' = factory();\n';
	}
	output += '  }\n';

	if (options.params.length > 0) {
		output += '}(this, function (' + options.params.join(', ') + ') {';
	} else {
		output += '}(this, function () {';
	}

	if (options.useStrict) {
		output += '\'use strict\';\n\n';
	}

	// module body
	if (options.useStrict) {
		output += contents.substring(options.useStrict.expression.range[1] + 1, options.bodyAst.range[1] - 1);
	}
	else {
		output += contents.substring(options.bodyAst.range[0] + 1, options.bodyAst.range[1] - 1);
	}
	output += '}));';

	// anything after define
	output += contents.substring(options.def.range[1], contents.length);

	return output;
};

module.exports = umdify;
